import numpy as np
import scipy.linalg as la
from scipy import linalg as la
from rlapy import RowSketcher


def qrcp_osid(Y, k, axis):
    """One-sided rank-k ID of Y using QR with column pivoting"""
    if axis == 1:
        # Column ID
        Q, S, J = la.qr(Y, mode='economic', pivoting=True)
        S_trailing = la.solve_triangular(S[:k, :k], S[:k, k:],
                                         overwrite_b=True,
                                         lower=False)
        Z = np.zeros((k, Y.shape[1]))
        Z[:, J] = np.hstack((np.eye(k), S_trailing))
        Js = J[:k]
        # Y \approx C @ Z; C = Y[:, Js]
        return Z, Js
    elif axis == 0:
        # Row ID
        Z, Is = qrcp_osid(Y.T, k, axis=1)
        X = Z.T
        return X, Is
    else:
        raise ValueError()


class RowOrColSelection:
    """selects (rows or columns) that are generated by ID"""

    def __call__(self, A, k, over, axis, gen):
        """
        Run a rank-k RowID (axis=0) or ColumnID (axis=1) on A,
        using oversampling parameter over, and only return the selected
        columns/rows

        Row selection a length-k index vector "Is"

        Column selection consists of a length-k index vector "Js" so
        that A \approx A[:,Js] @ Z. The columns of Z must contain a
        possibly-permuted k-by-k identity matrix.
        """
        raise NotImplementedError()


class ROCS1(RowOrColSelection):
    """
    Sketch + (QRCP skeleton)
    """

    def __init__(self, sk_op: RowSketcher):
        self.sk_op = sk_op

    def __call__(self, A, k, over, axis, rng):
        rng = np.random.default_rng(rng)
        if axis == 0:
            # Row ID
            Sk = self.sk_op(A, k + over, rng)
            Y = A @ Sk
            _, _, I = la.qr(Y.T, mode='economic', pivoting=True)
            Is = I[:k]
            return Is
        elif axis == 1:
            # Column ID
            Sk = self.sk_op(A.T, k + over, rng).T
            Y = Sk @ A
            _, _, J = la.qr(Y, mode='economic', pivoting=True)
            Js = J[:k]
            return Js
        else:
            raise ValueError()
