from parla.randblas.enums import DenseDist, Side, Op, Layout, Uplo, Diag
from parla.randblas.operators import SASO, prep_saso_sketching
from parla.randblas.operators import SketchingBuffer, prep_dense_buff_sketching
from parla.randblas.python_specific_helpers import write_back, to_2d_array
import numpy as np


# lskge3: [L]eft [SK]etch a [GE]neral matrix with a BLAS [3] operation (or operation of the same complexity).
# lskges: [L]eft [SK]etch a [GE]neral matrix with a [S]parse operator.
# lskgef: [L]eft [SK]etch a [GE]neral matrix with an [F]FT-like operator.


def lskge3(layout: Layout,
           transS: Op,
           transA: Op,
           d: int,  # B is d-by-n
           n: int,  # op(A) is m-by-n
           m: int,  # op(S) is d-by-m
           alpha: float,
           S0: SketchingBuffer,
           vpos: int,  # [virtual] pointer offset for S
           A_ptr: np.ndarray,
           lda: int,
           beta: float,
           B_ptr: np.ndarray,
           ldb: int):
    """
    [L]left-[SK]etch a [GE]neral matrix with a BLAS [3] operation,
    or an operation of the same complexity:

        B = alpha * op(S) @ op(A) + beta * B.

    Notes
    -----
    layout specifies the layout for (A, B) as represented
    by vectors A_ptr and B_ptr. It also specifies how we
    interpret the virtual pointer offset for S ("vpos").

    The sketch produced by this function is equivalent to
    one generated by a dense sketching operator defined by
    a two-step process:

    (1) Convert S0 to a dense matrix of shape (S0.n_rows, S0.n_cols).
        Store that matrix in a vectorized representation determined
        by "layout" (row major or column major). Set S0_ptr to the
        address at which the vectorized representation of S0 starts.

    (2) Interpret S as a pointer to a vectorized matrix starting at
        address &(S0_ptr[vpos]). Under the matrix interpretation, S
        has shape
            (d, m) if transS == NoTrans
            or
            (m, d) if transS == Trans.
        Under the vectorized representation, the leading dimension
        of S is
            S0.n_rows if layout == ColMajor
            or
            S0.n_cols if layout == RowMajor.
    """
    assert A_ptr.ndim == 1
    assert B_ptr.ndim == 1
    S0_ptr = prep_dense_buff_sketching(S0)

    # The dimensions for (A, S), rather than (op(A), op(S)).
    rows_A, cols_A = (m, n) if transA == Op.NoTrans else (n, m)
    rows_S, cols_S = (d, m) if transS == Op.NoTrans else (m, d)

    # Check that the dimensions for (A, B) are compatible with the
    # provided stride parameters (lda, ldb) we'll use for (A_ptr, B_ptr).
    if layout == Layout.ColMajor:
        lds = S0.n_rows
        assert lds >= rows_S
        assert lda >= rows_A
        assert ldb >= d
    else:
        lds = S0.n_cols
        assert lds >= cols_S
        assert lda >= cols_A
        assert ldb >= n
    S_ptr = S0_ptr[vpos:]

    # Convert to appropriate NumPy arrays, since we can't easily access BLAS directly.
    #   This won't be needed in RandBLAS.
    S = to_2d_array(S_ptr, rows_S, cols_S, lds, layout)
    A = to_2d_array(A_ptr, rows_A, cols_A, lda, layout)
    B = to_2d_array(B_ptr, d, n, ldb, layout)

    # Perform the multiplication
    if transS == Op.NoTrans and transA == Op.NoTrans:
        C = S @ A
    elif transS == Op.NoTrans and transA == Op.Trans:
        C = S @ A.T
    elif transS == Op.Trans and transA == Op.Trans:
        C = S.T @ A.T
    else:
        C = S.T @ A
    C *= alpha
    B *= beta
    B += C
    write_back(B, B_ptr, n, d, ldb, layout)
    pass


def lskges(layout: Layout,
           transS: Op,
           transA: Op,
           d: int,  # B is d-by-n
           n: int,  # op(A) is m-by-n
           m: int,  # op(S) is d-by-m
           alpha: float,
           S0: SASO,
           vpos: int,  # [virtual] pointer offset for S
           A_ptr: np.ndarray,
           lda: int,
           beta: float,
           B_ptr: np.ndarray,
           ldb: int):
    """
    [L]left-[SK]etch a [GE]neral matrix with a short-axis-sparse operator.

        B = alpha * op(S) @ op(A) + beta * B.

    Notes
    -----
    layout specifies the layout for (A, B) as represented
    by vectors A_ptr and B_ptr. It also specifies how we
    interpret the virtual pointer offset for S ("vpos").

    The sketch produced by this function is equivalent to
    one generated by a dense sketching operator defined by
    a two-step process:

    (1) Convert S0 to a dense matrix of shape (S0.n_rows, S0.n_cols).
        Store that matrix in a vectorized representation determined
        by "layout" (row major or column major). Set S0_ptr to the
        address at which the vectorized representation of S0 starts.

    (2) Interpret S as a pointer to a vectorized matrix starting at
        address &(S0_ptr[vpos]). Under the matrix interpretation, S
        has shape
            (d, m) if transS == NoTrans
            or
            (m, d) if transS == Trans.
        Under the vectorized representation, the leading dimension
        of S is
            S0.n_rows if layout == ColMajor
            or
            S0.n_cols if layout == RowMajor.
    """
    assert A_ptr.ndim == 1
    assert B_ptr.ndim == 1
    S0_data = prep_saso_sketching(S0)

    # The dimensions for (A, S), rather than (op(A), op(S)).
    rows_A, cols_A = (m, n) if transA == Op.NoTrans else (n, m)
    rows_S, cols_S = (d, m) if transS == Op.NoTrans else (m, d)
    assert rows_S <= S0.n_rows
    assert cols_S <= S0.n_cols

    # Check that the dimensions for (A, B) are compatible with the
    # provided stride parameters (lda, ldb) we'll use for (A_ptr, B_ptr).
    if layout == Layout.ColMajor:
        S_col_offset = vpos // S0.n_rows
        S_row_offset = vpos % S0.n_rows
        S = S0_data[:S_row_offset, :S_col_offset]
        assert lda >= rows_A
        assert ldb >= d
    else:
        S_row_offset = vpos // S0.n_cols
        S_col_offset = vpos % S0.n_cols
        S = S0_data[:S_row_offset, :S_col_offset]
        assert lda >= cols_A
        assert ldb >= n
    assert S.shape == (rows_S, cols_S)

    # Convert to appropriate NumPy arrays, since we can't easily access BLAS directly.
    #   This won't be needed in RandBLAS.
    A = to_2d_array(A_ptr, rows_A, cols_A, lda, layout)
    B = to_2d_array(B_ptr, d, n, ldb, layout)

    # Perform the multiplication
    if transS == Op.NoTrans and transA == Op.NoTrans:
        C = S @ A
    elif transS == Op.NoTrans and transA == Op.Trans:
        C = S @ A.T
    elif transS == Op.Trans and transA == Op.Trans:
        C = S.T @ A.T
    else:
        C = S.T @ A
    C *= alpha
    B *= beta
    B += C
    write_back(B, B_ptr, n, d, ldb, layout)
    pass


if __name__ == '__main__':
    # BLAS lets you take contiguous row-slices or column-slices by changing
    # the location of the "starting" pointer in some array.
    #
    #   Problems:
    #
    #       1. our API doesn't let you set the starting pointer for the
    #          sketching operator, so it only lets you take leading slices.
    #
    #       2. there isn't a notion of a starting pointer for sparse sketching
    #          operators.
    #
    #       3. SASOs aren't closed under selecting a subset of their rows.
    #
    S = SketchingBuffer(DenseDist.Uniform, 0, 0, n_rows=10, n_cols=50)
    np.random.seed(0)
    d = 10  # <= S.n_rows
    m = 40  # <= S.n_cols
    n = 4
    A = np.random.randn(m * n)
    lda = m
    B = np.zeros(d * n)
    ldb = d
    alpha = 1.0
    beta = 0.0
    lskge3(Layout.ColMajor,
           Op.NoTrans,
           Op.NoTrans,
           d, n, m,
           alpha, S, 0, A, lda,
           beta, B, ldb)
